## 补码，反码，原码



例 ：                                    【0101】       【1111】

补码：最高位为负值            1\*2^2+1=5     -1\*2^3+1\*2^2+1\*2^1+1=-1

反码：最高位为负值减一    1\*2^2+1=5     -1\*（2^3-1）+1\*2^2+1*2^1+1=0

原码：最高位为符号位        1\*2^2+1=5     -1\*（1\*2^2+1*2^1+1）=-7

 

拓展类型（int32->int64）

补码：用最高位补全相差的位数

 

## 补码的非

最小值补码的非等于自己，因为1000+1000=10000，负溢出，等于0000。

 

计算一个数的补码非的方法：找到最右边第一个1的位置，把这个1 左边所有位取反。

 

## 补码乘法

补码乘法等于按无符号数相乘最后取补码

 

## 乘以整数

整数乘法的代价比加法和移位的代价大很多，编译器会用乘以乘数的二次幂相加的方式。

如：x\*5=x\*(2^2+2^0)=(x<<2)+x

 

### 优化：

如果乘数里面出现连续的1如【0001110】，可以转化为

(x<<3)+(x<<2)+(x<<1)=x\*(2^3+2^2+2^1)=>x\*(2^4-2^1)=(x<<4)-(x<<1)

减少移位计算

 

同理存在少量0的情况，如：【11 0111】，可以转化为(x<<6)-(x<<3)-x



