- 在32位系统中，一个指针的大小是4字节，而在64位系统中位8字节，这导致了同样的程序在不同位的系统中难以移植，并且使得当程序处于64位系统中的时候，会多比其处于32位系统中多占用一部分内存。JVM为了解决其程序在32位系统移植到64位系统上之后，因为指针变大而多占用内存的问题，从JDK 1.6 update14开始，64 bit JVM正式支持了`` -XX:+UseCompressedOops ``这个可以压缩指针，起到节约内存占用的新参数。在开启压缩指针之后，当JVM通过对象地址来寻找对象的时候，会将地址右移三位（即扩大8倍），之后再通过移位之后的地址来寻找对象。这样就可以通过4字节的指针来管理32GB的内存大小。抽象的讲，就是通过降低指针寻址的粒度来增加其寻址范围。而之所以是8倍，是因为JVM的对象强制为8字节对齐，所以将指针的寻址粒度提升为8字节并不会出现无法获取合法对象的问题。
- 存储设备：众所周知，对于一个存储设备来讲，容量，速度，价格三者不可兼得。考虑到CPU的运行速度远快于存储设备IO的速度，所以我们需要使用寄存器，L1，L2，L3，内存，硬盘，网盘这多级存储结构（从前到后，容量变大，速度变慢）来对整个系统的存储进行优化，来提高整个系统的运行效率。
  - tips：
    - 硬盘顺序IO的速度与内存的IO速度差距并不是很大。
    - 在一个拥有独立内存的集群系统中，集群中的每一个系统都能快速访问本地内存，而高速集群中的每个计算机之间的远程访问则会存在一定程度上的延迟。所以诞生了**非均衡内存访问（NUMA：Non-Uniform Memory Access）系统**，为这种系统提供了共享内存编程模型。尽管NUMA集群在商业上并没有获取广泛的成功，但是伴随着共享内存多处理器系统已经扩展到大量处理器规模，使得它的内存被分为了多个部分，导致其在内存架构上已经展现出了逐渐增长的非均衡型，最终使得NUMA的设计概念，编程模式，优化技术正在被共享内存多处理器领域所采用。而软件也在不断跟进对于NUMA架构的优化。比如说JDK11带来的全新的**ZGC**就能够能自动感知NUMA架构并充分利用NUMA架构特性。
- 数字编码：主流的数字编码是一个数字固定长度，而有符号数相较于无符号数的区别在于有符号数的最高有效位即为符号位，权重为 $-2^{w-1}$。而protobuf中对于数字有一套不同的编码方式：varint和ZigZag编码，详见：https://juejin.im/post/6844904025578553351。相较于主流的数字编码方式，varint和zigzag编码极为不利于数字的计算，但是当数字较小时，更为利于存储和传输。

